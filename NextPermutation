/* 1 3 5 4 2 ---> 1 4 2 3 5
    
    algorithm --> 
    step 1-> traverse from right to left & find the first index "idx1" s.t. arr[idx1]<arr[idx+1]
    step 2-> find the smallest element greater than "idx1" while traversing from right to left.
    step 3-> swap (idx1,idx2)
    step 4-> reverse(idx+1,n-1);
    
    Time Comp -> O(n) , Space Comp-> O(1 )
    */
    void nextPermutation(vector<int>& nums) {
        int n=nums.size();
        int idx1,idx2;
        for(idx1=n-2;idx1>=0;idx1--){
            if(nums[idx1+1]>nums[idx1])
                break;
        }
        if(idx1<0)
            reverse(nums.begin(),nums.end());
        else{
            for(idx2=n-1;idx2>idx1;idx2--){
                if(nums[idx2]>nums[idx1])
                    break;
            }
            swap(nums[idx1],nums[idx2]);
            reverse(nums.begin()+idx1+1,nums.end());
        }
    }
};
